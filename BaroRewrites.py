import sys
import os

# this is:
# directory ?? "" or
# directory != null ? directory : ""
# or:
def directory_fixer(directory):
    # None is Null in python?
    if directory == None:
        directory = ""
    else:
        directory = directory
# this is:
# startPath = saveFolder.EndsWith('/') ? saveFolder : $"{saveFoler}/";
def path_addslashend(saveFolder: str):
    # TODO use trim to make sure that there are no white space at the end of the string
    if saveFolder.trim()[-1] == '/':
        return saveFolder
    else:
        return saveFolder + '/'

# https://github.com/evilfactory/LuaCsForBarotrauma/blob/6b149e0498b9b634847c867ec6a211532f609c7b/Barotrauma/BarotraumaShared/SharedSource/Utils/ToolBox.cs#L32
# Toolbox.cs -> ToolBox/IsProperFilenameCase
def isProperFilenameCase(filename: str):
    if sys.platform == 'win32':
        return True
    else:
        corrected = True
        CorrectFilenameCase(filename, corrected)
        return (not corrected)

# https://github.com/evilfactory/LuaCsForBarotrauma/blob/6b149e0498b9b634847c867ec6a211532f609c7b/Barotrauma/BarotraumaShared/SharedSource/Utils/ToolBox.cs#L46
# unfortunetly had to use chatgpt due to time and skill constraints
# TODO please check and correct this
def CorrectFilenameCase(filename, directory="", corrected=False):
    delimiters = ['/', '\\']
    subDirs = filename.split(delimiters)
    originalFilename = filename
    filename = ""

    if not os.name == 'nt':
        if os.path.exists(originalFilename):
            return originalFilename

    startPath = directory_fixer(directory)

    saveFolder = SaveUtil.DefaultSaveFolder.replace('\\', '/')
    if originalFilename.replace('\\', '/').startswith(saveFolder):
        startPath = saveFolder if saveFolder.endswith('/') else f"{saveFolder}/"
        filename = startPath
        subDirs = subDirs[len(saveFolder.split('/')):]
    elif os.path.isabs(originalFilename):
        # TODO: incorrect assumption or...? Figure out what this was actually supposed to fix, if anything. Might've been a perf thing.
        return originalFilename  # assume that rooted paths have correct case since these are generated by the game

    for i, subDir in enumerate(subDirs):
        if i == len(subDirs) - 1 and (not subDir or subDir.isspace()):
            break

        subDir = subDir.rstrip()
        enumPath = os.path.join(startPath, filename)

        if not filename.strip():
            enumPath = "./" if not startPath.strip() else startPath

        filePaths = [os.path.basename(f) for f in os.listdir(enumPath)]

        if any(s == subDir for s in filePaths):
            filename += subDir
        else:
            correctedPaths = [s for s in filePaths if s.lower() == subDir.lower()]
            if correctedPaths:
                corrected = True
                filename += correctedPaths[0]
            else:
                # DebugConsole.ThrowError(f"File \"{originalFilename}\" not found!")
                corrected = False
                return originalFilename

        if i < len(subDirs) - 1:
            filename += "/"

    return filename


# https://github.com/evilfactory/LuaCsForBarotrauma/blob/6b149e0498b9b634847c867ec6a211532f609c7b/Barotrauma/BarotraumaShared/SharedSource/Utils/ToolBox.cs#L601
#:barodev: <summary>
#:barodev: Cleans up a path by replacing backslashes with forward slashes, and
#:barodev: optionally corrects the casing of the path. Recommended when serializing
#:barodev: paths to a human-readable file to force case correction on all platforms.
#:barodev: Also useful when working with paths to files that currently don't exist,
#:barodev: i.e. case cannot be corrected.
#:barodev: </summary>
#:barodev: <param name="path">Path to clean up</param>
#:barodev: <param name="correctFilenameCase">Should the case be corrected to match the filesystem?</param>
#:barodev: <param name="directory">Directories that the path should be found in, not returned.</param>
#:barodev: <returns>Path with corrected slashes, and corrected case if requested.</returns>
def CleanUpPathCrossPlatform(path, correct_filename_case=True, directory=""):
    if not path:
        return ""

    path = path.replace('\\', '/')
    if path.startswith("file:", 0, 5):
        path = path[5:]

    while "//" in path:
        path = path.replace("//", "/")

    if correct_filename_case:
        corrected_path = CorrectFilenameCase(path, directory)
        if corrected_path:
            path = corrected_path

    return path

# https://github.com/evilfactory/LuaCsForBarotrauma/blob/6b149e0498b9b634847c867ec6a211532f609c7b/Barotrauma/BarotraumaShared/SharedSource/Utils/ToolBox.cs#L633C30-L633C41
#:barodev: <summary>
#:barodev: Cleans up a path by replacing backslashes with forward slashes, and
#:barodev: corrects the casing of the path on non-Windows platforms. Recommended
#:barodev: when loading a path from a file, to make sure that it is found on all
#:barodev: platforms when attempting to open it.
#:barodev: </summary>
#:barodev: <param name="path">Path to clean up</param>
#:barodev: <returns>Path with corrected slashes, and corrected case if required by the platform.</returns>
def CleanUpPath(path):
    return CleanUpPathCrossPlatform(path, correct_filename_case=not (os.name == 'nt'))